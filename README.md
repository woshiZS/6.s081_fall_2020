> 本次实验需要多进程和锁以及调度的知识（Interrupt也会提到），故把课程笔记写在这里

### 9.1 真实操作系统的内存使用情况

* 大部分内存都会被使用，并且RES（实际使用的内存量）比VIRT（虚拟内存的地址空间的大小）小得多。

### 9.2 Interrupt硬件部分

* 中断的过程类似于之前的系统调用
* 中断与系统调用存在区别
  * 硬件生成中断时，interrupt handler和当前进程在CPU是没有关联的，但是系统调用时发生的原来进程的context下。

### 10.1 为什么要使用锁 && 10.2 锁如何避免race condition

出现data race的情况，为了确保共享数据的正确性，我们需要锁，可以保证对共享数据的操作为串行。

如果给共享数据加锁，需要在acquire和release之间（critical area)中对数据进行操作，但是并没有说强制用锁，是否用锁完全取决于程序员，如果需要对一段代码增加原子性，是由程序员决定是否增加锁的acquire和release。

### 10.3 什么时候用锁

* 比较保守的规则，如果两个进程访问了一个共享的数据结构，并且其中一个进程会更新共享的数据，那么就需要对这个共享的数据结构加锁。
* 在某些场景，不满足上述条件的时候也会需要锁，例如printf输出的时候，我们传递一个字符串给它，xv6会尝试将字符串原子的输出而非和其他进程的输出所交织。
* 锁应该和操作相关连而非数据结构相关联。（这里举的一个例子，将d1目录下的x文件移动到d2目录下的y文件，如果先对d1加锁删除x文件，释放d1锁，获取d2锁再添加y文件，这样就是错误的做法，因为在删除和添加之间的时间节点，其他的进程会看到x文件消失了，但是又没有新的文件出现。所以正确的做法是，同时获取两个目录的，删除和添加在同一个critical area中执行。

### 10.4 锁的特性和死锁

* 锁可以避免丢失更新，race condition的时候某一方的写操作可能会被覆盖
* 锁可以将一段操作赋予原子性
* 锁可以维护共享数据结构的不变性。

锁可能会带来的问题

1. 死锁

​	产生的条件，一个进程获取一个锁，在没有释放前，再次acquire这个锁。

​	另外就是两个进程获取两个相同的锁，但是获取的顺序不一致，导致循环等待

​	针对第二个问题，我们通常选择对全局的锁进行排序，获取锁的时候通常按照确定的顺去去获取。

​	但是这种做法也可能会出现一个问题，就是两个模块之间有互相调用的时候，模块a需要获取模块b中锁的数据，所以这样会使得代码的模块化变得很差，代码耦合性变强。

**如果两个锁不会在同一个操作中被获取，那么这两组锁的排序是完全独立的。排序的时候只需要对共用的锁进行排序即可**

### 锁与性能

主要讲的是如果我们需要更好的并发效能，就应该进一步去拆分数据结构，增加粒度更细的锁，将critical area限制到最小，但是这样往往需要大量的工作，所以是否应该重新设计还是取决于性能的测试结果。

### Part1. switching between Uthreads

* 完成用户线程的创建和context switch，uthread.c缺失了线程创建和切换的一些代码，需要我们去补充。
* 填充thread_create, thread_schedule()以及thread_switch(汇编，参考原来的swtch)
* 注意schedule到初次执行的线程时，需要切换到thread_create内部。
* save和restore的代码位置很重要！
* 在struct thread中存储这些寄存器是一个不错的计划
* thread_schedule()内部需要对thread_swtich进行调用
* 将thread_switch()看做函数调用，调用前会保存caller_saved registers，所以在function内部只需要保存callee saved registers。
* volatile适用场景，mmio(外围设备), 中断处理，多线程共享的全局变量，提示编译器不要对volatile修饰的变量做过度优化，volatile指针（底层）会每次都read对应位置的内存。